"use strict";
(self["webpackChunkfind_you_future_app"] = self["webpackChunkfind_you_future_app"] || []).push([["node_modules_ionic_core_dist_esm_ion-route_4_entry_js"],{

/***/ 54990:
/*!****************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/ion-route_4.entry.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_route": function() { return /* binding */ Route; },
/* harmony export */   "ion_route_redirect": function() { return /* binding */ RouteRedirect; },
/* harmony export */   "ion_router": function() { return /* binding */ Router; },
/* harmony export */   "ion_router_link": function() { return /* binding */ RouterLink; }
/* harmony export */ });
/* harmony import */ var _Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ 19369);
/* harmony import */ var _index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-e806d1f6.js */ 56837);
/* harmony import */ var _ionic_global_9d5c8ee3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ionic-global-9d5c8ee3.js */ 11072);
/* harmony import */ var _helpers_90f46169_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers-90f46169.js */ 48374);
/* harmony import */ var _theme_ff3fc52f_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./theme-ff3fc52f.js */ 43784);





const Route = class {
  constructor(hostRef) {
    (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionRouteDataChanged = (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteDataChanged", 7);
    /**
     * Relative path that needs to match in order for this route to apply.
     *
     * Accepts paths similar to expressjs so that you can define parameters
     * in the url /foo/:bar where bar would be available in incoming props.
     */

    this.url = '';
  }

  onUpdate(newValue) {
    this.ionRouteDataChanged.emit(newValue);
  }

  onComponentProps(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }

    const keys1 = newValue ? Object.keys(newValue) : [];
    const keys2 = oldValue ? Object.keys(oldValue) : [];

    if (keys1.length !== keys2.length) {
      this.onUpdate(newValue);
      return;
    }

    for (const key of keys1) {
      if (newValue[key] !== oldValue[key]) {
        this.onUpdate(newValue);
        return;
      }
    }
  }

  connectedCallback() {
    this.ionRouteDataChanged.emit();
  }

  static get watchers() {
    return {
      "url": ["onUpdate"],
      "component": ["onUpdate"],
      "componentProps": ["onComponentProps"]
    };
  }

};
const RouteRedirect = class {
  constructor(hostRef) {
    (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionRouteRedirectChanged = (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteRedirectChanged", 7);
  }

  propDidChange() {
    this.ionRouteRedirectChanged.emit();
  }

  connectedCallback() {
    this.ionRouteRedirectChanged.emit();
  }

  static get watchers() {
    return {
      "from": ["propDidChange"],
      "to": ["propDidChange"]
    };
  }

};
const ROUTER_INTENT_NONE = 'root';
const ROUTER_INTENT_FORWARD = 'forward';
const ROUTER_INTENT_BACK = 'back';

const generatePath = segments => {
  const path = segments.filter(s => s.length > 0).join('/');
  return '/' + path;
};

const chainToPath = chain => {
  const path = [];

  for (const route of chain) {
    for (const segment of route.path) {
      if (segment[0] === ':') {
        const param = route.params && route.params[segment.slice(1)];

        if (!param) {
          return null;
        }

        path.push(param);
      } else if (segment !== '') {
        path.push(segment);
      }
    }
  }

  return path;
};

const writePath = (history, root, useHash, path, direction, state, queryString) => {
  let url = generatePath([...parsePath(root), ...path]);

  if (useHash) {
    url = '#' + url;
  }

  if (queryString !== undefined) {
    url = url + '?' + queryString;
  }

  if (direction === ROUTER_INTENT_FORWARD) {
    history.pushState(state, '', url);
  } else {
    history.replaceState(state, '', url);
  }
};

const removePrefix = (prefix, path) => {
  if (prefix.length > path.length) {
    return null;
  }

  if (prefix.length <= 1 && prefix[0] === '') {
    return path;
  }

  for (let i = 0; i < prefix.length; i++) {
    if (prefix[i].length > 0 && prefix[i] !== path[i]) {
      return null;
    }
  }

  if (path.length === prefix.length) {
    return [''];
  }

  return path.slice(prefix.length);
};

const readPath = (loc, root, useHash) => {
  let pathname = loc.pathname;

  if (useHash) {
    const hash = loc.hash;
    pathname = hash[0] === '#' ? hash.slice(1) : '';
  }

  const prefix = parsePath(root);
  const path = parsePath(pathname);
  return removePrefix(prefix, path);
};

const parsePath = path => {
  if (path == null) {
    return [''];
  }

  const removeQueryString = path.split('?')[0];
  const segments = removeQueryString.split('/').map(s => s.trim()).filter(s => s.length > 0);

  if (segments.length === 0) {
    return [''];
  } else {
    return segments;
  }
};

const printRoutes = routes => {
  console.group(`[ion-core] ROUTES[${routes.length}]`);

  for (const chain of routes) {
    const path = [];
    chain.forEach(r => path.push(...r.path));
    const ids = chain.map(r => r.id);
    console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\t', `(${ids.join(', ')})`);
  }

  console.groupEnd();
};

const printRedirects = redirects => {
  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);

  for (const redirect of redirects) {
    if (redirect.to) {
      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to)}`, 'font-weight: bold');
    }
  }

  console.groupEnd();
};

const writeNavState = /*#__PURE__*/function () {
  var _ref = (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* (root, chain, direction, index, changed = false, animation) {
    try {
      // find next navigation outlet in the DOM
      const outlet = searchNavNode(root); // make sure we can continue interacting the DOM, otherwise abort

      if (index >= chain.length || !outlet) {
        return changed;
      }

      yield outlet.componentOnReady();
      const route = chain[index];
      const result = yield outlet.setRouteId(route.id, route.params, direction, animation); // if the outlet changed the page, reset navigation to neutral (no direction)
      // this means nested outlets will not animate

      if (result.changed) {
        direction = ROUTER_INTENT_NONE;
        changed = true;
      } // recursively set nested outlets


      changed = yield writeNavState(result.element, chain, direction, index + 1, changed, animation); // once all nested outlets are visible let's make the parent visible too,
      // using markVisible prevents flickering

      if (result.markVisible) {
        yield result.markVisible();
      }

      return changed;
    } catch (e) {
      console.error(e);
      return false;
    }
  });

  return function writeNavState(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

const readNavState = /*#__PURE__*/function () {
  var _ref2 = (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* (root) {
    const ids = [];
    let outlet;
    let node = root; // tslint:disable-next-line:no-constant-condition

    while (true) {
      outlet = searchNavNode(node);

      if (outlet) {
        const id = yield outlet.getRouteId();

        if (id) {
          node = id.element;
          id.element = undefined;
          ids.push(id);
        } else {
          break;
        }
      } else {
        break;
      }
    }

    return {
      ids,
      outlet
    };
  });

  return function readNavState(_x5) {
    return _ref2.apply(this, arguments);
  };
}();

const waitUntilNavNode = () => {
  if (searchNavNode(document.body)) {
    return Promise.resolve();
  }

  return new Promise(resolve => {
    window.addEventListener('ionNavWillLoad', resolve, {
      once: true
    });
  });
};

const QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';

const searchNavNode = root => {
  if (!root) {
    return undefined;
  }

  if (root.matches(QUERY)) {
    return root;
  }

  const outlet = root.querySelector(QUERY);
  return outlet ? outlet : undefined;
};

const matchesRedirect = (input, route) => {
  const {
    from,
    to
  } = route;

  if (to === undefined) {
    return false;
  }

  if (from.length > input.length) {
    return false;
  }

  for (let i = 0; i < from.length; i++) {
    const expected = from[i];

    if (expected === '*') {
      return true;
    }

    if (expected !== input[i]) {
      return false;
    }
  }

  return from.length === input.length;
};

const routeRedirect = (path, routes) => {
  return routes.find(route => matchesRedirect(path, route));
};

const matchesIDs = (ids, chain) => {
  const len = Math.min(ids.length, chain.length);
  let i = 0;

  for (; i < len; i++) {
    if (ids[i].toLowerCase() !== chain[i].id) {
      break;
    }
  }

  return i;
};

const matchesPath = (inputPath, chain) => {
  const segments = new RouterSegments(inputPath);
  let matchesDefault = false;
  let allparams;

  for (let i = 0; i < chain.length; i++) {
    const path = chain[i].path;

    if (path[0] === '') {
      matchesDefault = true;
    } else {
      for (const segment of path) {
        const data = segments.next(); // data param

        if (segment[0] === ':') {
          if (data === '') {
            return null;
          }

          allparams = allparams || [];
          const params = allparams[i] || (allparams[i] = {});
          params[segment.slice(1)] = data;
        } else if (data !== segment) {
          return null;
        }
      }

      matchesDefault = false;
    }
  }

  const matches = matchesDefault ? matchesDefault === (segments.next() === '') : true;

  if (!matches) {
    return null;
  }

  if (allparams) {
    return chain.map((route, i) => ({
      id: route.id,
      path: route.path,
      params: mergeParams(route.params, allparams[i]),
      beforeEnter: route.beforeEnter,
      beforeLeave: route.beforeLeave
    }));
  }

  return chain;
};

const mergeParams = (a, b) => {
  if (!a && b) {
    return b;
  } else if (a && !b) {
    return a;
  } else if (a && b) {
    return Object.assign(Object.assign({}, a), b);
  }

  return undefined;
};

const routerIDsToChain = (ids, chains) => {
  let match = null;
  let maxMatches = 0;
  const plainIDs = ids.map(i => i.id);

  for (const chain of chains) {
    const score = matchesIDs(plainIDs, chain);

    if (score > maxMatches) {
      match = chain;
      maxMatches = score;
    }
  }

  if (match) {
    return match.map((route, i) => ({
      id: route.id,
      path: route.path,
      params: mergeParams(route.params, ids[i] && ids[i].params)
    }));
  }

  return null;
};

const routerPathToChain = (path, chains) => {
  let match = null;
  let matches = 0;

  for (const chain of chains) {
    const matchedChain = matchesPath(path, chain);

    if (matchedChain !== null) {
      const score = computePriority(matchedChain);

      if (score > matches) {
        matches = score;
        match = matchedChain;
      }
    }
  }

  return match;
};

const computePriority = chain => {
  let score = 1;
  let level = 1;

  for (const route of chain) {
    for (const path of route.path) {
      if (path[0] === ':') {
        score += Math.pow(1, level);
      } else if (path !== '') {
        score += Math.pow(2, level);
      }

      level++;
    }
  }

  return score;
};

class RouterSegments {
  constructor(path) {
    this.path = path.slice();
  }

  next() {
    if (this.path.length > 0) {
      return this.path.shift();
    }

    return '';
  }

}

const readRedirects = root => {
  return Array.from(root.children).filter(el => el.tagName === 'ION-ROUTE-REDIRECT').map(el => {
    const to = readProp(el, 'to');
    return {
      from: parsePath(readProp(el, 'from')),
      to: to == null ? undefined : parsePath(to)
    };
  });
};

const readRoutes = root => {
  return flattenRouterTree(readRouteNodes(root));
};

const readRouteNodes = (root, node = root) => {
  return Array.from(node.children).filter(el => el.tagName === 'ION-ROUTE' && el.component).map(el => {
    const component = readProp(el, 'component');

    if (component == null) {
      throw new Error('component missing in ion-route');
    }

    return {
      path: parsePath(readProp(el, 'url')),
      id: component.toLowerCase(),
      params: el.componentProps,
      beforeLeave: el.beforeLeave,
      beforeEnter: el.beforeEnter,
      children: readRouteNodes(root, el)
    };
  });
};

const readProp = (el, prop) => {
  if (prop in el) {
    return el[prop];
  }

  if (el.hasAttribute(prop)) {
    return el.getAttribute(prop);
  }

  return null;
};

const flattenRouterTree = nodes => {
  const routes = [];

  for (const node of nodes) {
    flattenNode([], routes, node);
  }

  return routes;
};

const flattenNode = (chain, routes, node) => {
  const s = chain.slice();
  s.push({
    id: node.id,
    path: node.path,
    params: node.params,
    beforeLeave: node.beforeLeave,
    beforeEnter: node.beforeEnter
  });

  if (node.children.length === 0) {
    routes.push(s);
    return;
  }

  for (const sub of node.children) {
    flattenNode(s, routes, sub);
  }
};

const Router = class {
  constructor(hostRef) {
    (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionRouteWillChange = (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteWillChange", 7);
    this.ionRouteDidChange = (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteDidChange", 7);
    this.previousPath = null;
    this.busy = false;
    this.state = 0;
    this.lastState = 0;
    /**
     * By default `ion-router` will match the routes at the root path ("/").
     * That can be changed when
     *
     */

    this.root = '/';
    /**
     * The router can work in two "modes":
     * - With hash: `/index.html#/path/to/page`
     * - Without hash: `/path/to/page`
     *
     * Using one or another might depend in the requirements of your app and/or where it's deployed.
     *
     * Usually "hash-less" navigation works better for SEO and it's more user friendly too, but it might
     * requires additional server-side configuration in order to properly work.
     *
     * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.
     *
     * By default, this property is `true`, change to `false` to allow hash-less URLs.
     */

    this.useHash = true;
  }

  componentWillLoad() {
    var _this = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      console.debug('[ion-router] router will load');
      yield waitUntilNavNode();
      console.debug('[ion-router] found nav');
      yield _this.onRoutesChanged();
    })();
  }

  componentDidLoad() {
    window.addEventListener('ionRouteRedirectChanged', (0,_helpers_90f46169_js__WEBPACK_IMPORTED_MODULE_3__.m)(this.onRedirectChanged.bind(this), 10));
    window.addEventListener('ionRouteDataChanged', (0,_helpers_90f46169_js__WEBPACK_IMPORTED_MODULE_3__.m)(this.onRoutesChanged.bind(this), 100));
  }

  onPopState() {
    var _this2 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      const direction = _this2.historyDirection();

      let path = _this2.getPath();

      const canProceed = yield _this2.runGuards(path);

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          path = parsePath(canProceed.redirect);
        }

        return false;
      }

      console.debug('[ion-router] URL changed -> update nav', path, direction);
      return _this2.writeNavStateRoot(path, direction);
    })();
  }

  onBackButton(ev) {
    ev.detail.register(0, processNextHandler => {
      this.back();
      processNextHandler();
    });
  }
  /** @internal */


  canTransition() {
    var _this3 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      const canProceed = yield _this3.runGuards();

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          return canProceed.redirect;
        } else {
          return false;
        }
      }

      return true;
    })();
  }
  /**
   * Navigate to the specified URL.
   *
   * @param url The url to navigate to.
   * @param direction The direction of the animation. Defaults to `"forward"`.
   */


  push(url, direction = 'forward', animation) {
    var _this4 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      if (url.startsWith('.')) {
        url = new URL(url, window.location.href).pathname;
      }

      console.debug('[ion-router] URL pushed -> updating nav', url, direction);
      let path = parsePath(url);
      let queryString = url.split('?')[1];
      const canProceed = yield _this4.runGuards(path);

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          path = parsePath(canProceed.redirect);
          queryString = canProceed.redirect.split('?')[1];
        } else {
          return false;
        }
      }

      _this4.setPath(path, direction, queryString);

      return _this4.writeNavStateRoot(path, direction, animation);
    })();
  }
  /**
   * Go back to previous page in the window.history.
   */


  back() {
    window.history.back();
    return Promise.resolve(this.waitPromise);
  }
  /** @internal */


  printDebug() {
    var _this5 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      console.debug('CURRENT PATH', _this5.getPath());
      console.debug('PREVIOUS PATH', _this5.previousPath);
      printRoutes(readRoutes(_this5.el));
      printRedirects(readRedirects(_this5.el));
    })();
  }
  /** @internal */


  navChanged(direction) {
    var _this6 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      if (_this6.busy) {
        console.warn('[ion-router] router is busy, navChanged was cancelled');
        return false;
      }

      const {
        ids,
        outlet
      } = yield readNavState(window.document.body);
      const routes = readRoutes(_this6.el);
      const chain = routerIDsToChain(ids, routes);

      if (!chain) {
        console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));
        return false;
      }

      const path = chainToPath(chain);

      if (!path) {
        console.warn('[ion-router] router could not match path because some required param is missing');
        return false;
      }

      console.debug('[ion-router] nav changed -> update URL', ids, path);

      _this6.setPath(path, direction);

      yield _this6.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);
      return true;
    })();
  }

  onRedirectChanged() {
    const path = this.getPath();

    if (path && routeRedirect(path, readRedirects(this.el))) {
      this.writeNavStateRoot(path, ROUTER_INTENT_NONE);
    }
  }

  onRoutesChanged() {
    return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);
  }

  historyDirection() {
    const win = window;

    if (win.history.state === null) {
      this.state++;
      win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);
    }

    const state = win.history.state;
    const lastState = this.lastState;
    this.lastState = state;

    if (state > lastState || state >= lastState && lastState > 0) {
      return ROUTER_INTENT_FORWARD;
    } else if (state < lastState) {
      return ROUTER_INTENT_BACK;
    } else {
      return ROUTER_INTENT_NONE;
    }
  }

  writeNavStateRoot(path, direction, animation) {
    var _this7 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      if (!path) {
        console.error('[ion-router] URL is not part of the routing set');
        return false;
      } // lookup redirect rule


      const redirects = readRedirects(_this7.el);
      const redirect = routeRedirect(path, redirects);
      let redirectFrom = null;

      if (redirect) {
        _this7.setPath(redirect.to, direction);

        redirectFrom = redirect.from;
        path = redirect.to;
      } // lookup route chain


      const routes = readRoutes(_this7.el);
      const chain = routerPathToChain(path, routes);

      if (!chain) {
        console.error('[ion-router] the path does not match any route');
        return false;
      } // write DOM give


      return _this7.safeWriteNavState(document.body, chain, direction, path, redirectFrom, 0, animation);
    })();
  }

  safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {
    var _this8 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      const unlock = yield _this8.lock();
      let changed = false;

      try {
        changed = yield _this8.writeNavState(node, chain, direction, path, redirectFrom, index, animation);
      } catch (e) {
        console.error(e);
      }

      unlock();
      return changed;
    })();
  }

  lock() {
    var _this9 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      const p = _this9.waitPromise;
      let resolve;
      _this9.waitPromise = new Promise(r => resolve = r);

      if (p !== undefined) {
        yield p;
      }

      return resolve;
    })();
  }

  runGuards(to = this.getPath(), from = parsePath(this.previousPath)) {
    var _this10 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      if (!to || !from) {
        return true;
      }

      const routes = readRoutes(_this10.el);
      const toChain = routerPathToChain(to, routes);
      const fromChain = routerPathToChain(from, routes);
      const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;
      const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;
      const canLeave = beforeLeaveHook ? yield beforeLeaveHook() : true;

      if (canLeave === false || typeof canLeave === 'object') {
        return canLeave;
      }

      const canEnter = beforeEnterHook ? yield beforeEnterHook() : true;

      if (canEnter === false || typeof canEnter === 'object') {
        return canEnter;
      }

      return true;
    })();
  }

  writeNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {
    var _this11 = this;

    return (0,_Users_ferro_Desktop_United_Way_FYF_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(function* () {
      if (_this11.busy) {
        console.warn('[ion-router] router is busy, transition was cancelled');
        return false;
      }

      _this11.busy = true; // generate route event and emit will change

      const routeEvent = _this11.routeChangeEvent(path, redirectFrom);

      if (routeEvent) {
        _this11.ionRouteWillChange.emit(routeEvent);
      }

      const changed = yield writeNavState(node, chain, direction, index, false, animation);
      _this11.busy = false;

      if (changed) {
        console.debug('[ion-router] route changed', path);
      } // emit did change


      if (routeEvent) {
        _this11.ionRouteDidChange.emit(routeEvent);
      }

      return changed;
    })();
  }

  setPath(path, direction, queryString) {
    this.state++;
    writePath(window.history, this.root, this.useHash, path, direction, this.state, queryString);
  }

  getPath() {
    return readPath(window.location, this.root, this.useHash);
  }

  routeChangeEvent(path, redirectFromPath) {
    const from = this.previousPath;
    const to = generatePath(path);
    this.previousPath = to;

    if (to === from) {
      return null;
    }

    const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;
    return {
      from,
      redirectedFrom,
      to
    };
  }

  get el() {
    return (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.i)(this);
  }

};
const routerLinkCss = ":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}";
const RouterLink = class {
  constructor(hostRef) {
    (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    /**
     * When using a router, it specifies the transition direction when navigating to
     * another page using `href`.
     */

    this.routerDirection = 'forward';

    this.onClick = ev => {
      (0,_theme_ff3fc52f_js__WEBPACK_IMPORTED_MODULE_4__.o)(this.href, ev, this.routerDirection, this.routerAnimation);
    };
  }

  render() {
    const mode = (0,_ionic_global_9d5c8ee3_js__WEBPACK_IMPORTED_MODULE_2__.b)(this);
    const attrs = {
      href: this.href,
      rel: this.rel,
      target: this.target
    };
    return (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.H, {
      onClick: this.onClick,
      class: (0,_theme_ff3fc52f_js__WEBPACK_IMPORTED_MODULE_4__.c)(this.color, {
        [mode]: true,
        'ion-activatable': true
      })
    }, (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.h)("a", Object.assign({}, attrs), (0,_index_e806d1f6_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null)));
  }

};
RouterLink.style = routerLinkCss;


/***/ })

}]);
//# sourceMappingURL=node_modules_ionic_core_dist_esm_ion-route_4_entry_js-es2015.js.map